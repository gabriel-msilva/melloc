[{"content":" Programming for Data Analysis can be quite different in some aspects of “traditional” software development. At first, you don’t expect a specific input (dependent variables, or features) and you must iterate a lot until you get a satisfactory output (predictions of a model). There is a lot more exploring. Often you stop typing to ask yourself:\n “What is the mean of variable \\(X\\)?” “How the distribution of values looks like?” “How the models’ performance compare?”  You are very much likely to fail on your earlier assumptions. This is normal, but you should – to borrow a system design concept – fail fast. You want to iterate quickly over analysis and visualizations to better understand the data set you are dealing with. Also, you want to test different algorithms to select the best for the problem in question.\nTherefore, the development workflow in Data Science tends to be quite different from traditional software too. Quick iteration is one of the reasons why interpreted languages (like Python and R) are used way more often than compiled languages in Data Science. We should take the most out of this by configuring our development environment properly.\nRStudio and Spyder are quite similar in their workflow: you have text editing for scripts, an iterative shell for running code, a panel for displaying plots, data frame inspector, all integrated for you. RStudio is focused on R and Spyder, while a great Python IDE for Data Science, does not have the best interface (yet?). Another popular IDE for Data Science is JupyterLab, but it is way more focused on notebooks and needs a lot of tinkering for be a good development environment for scripts.\nThen, there is the well-known Visual Studio Code, or VS Code for short, that is used for many programming languages and purposes. It is not an out-of-box IDE for Data Science like the previous ones, but its versatility is worth it.\nThere are quite a number of VS Code extensions for Data Science (like Jupyter). But on this post, I will show how to configure IPython in VS Code for an enhanced interactive Python shell and kernel.\nIPython overview IPython adds many features on top of the default Python shell, like auto-completion, input history, and “magic commands” to control the environment or perform tasks. It is also highlights syntax, so that is nice. By using the Python shell efficiently, you are very likely to change your workflow and be more productive.\nAfter integrating it to my development environment, I barely see a reason to use Jupyter notebooks. The exception would be for presenting reports with plots and tables, or for educational purposes. You can easily explore and inspect objects on the terminal and, after getting the hang of it, it is faster than running cells.\nExample usage Suppose you started to explore your data and you have the following Python script,\nimport pandas as pd df = pd.DataFrame({\u0026quot;x\u0026quot;: [1, 2, 3], \u0026quot;y\u0026quot;: [\u0026quot;a\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;]}) When integrated to the VS Code terminal, you can run selected lines with Shift + Enter. Running it the first time will start an IPython shell in your terminal. You can also open the Command Palette (Ctrl + Shift + P) and select Python: Start REPL.\nIn [1]: import pandas as pd ...: ...: df = pd.DataFrame({\u0026quot;x\u0026quot;: [1, 2, 3], \u0026quot;y\u0026quot;: [\u0026quot;a\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;]}) Before writing any more code to your script, you can explore your data set in the IPython console.\nIn [2]: df Out[2]: # x y # 0 1 a # 1 2 a # 2 3 b In [3]: df.describe() Out[3]: # x # count 3.0 # mean 2.0 # std 1.0 # min 1.0 # 25% 1.5 # 50% 2.0 # 75% 2.5 # max 3.0 In [4]: df[\u0026quot;y\u0026quot;].value_counts() Out[4]: # a 2 # b 1 # Name: y, dtype: int64 You can also type ? after an object to inspect it.\nIn [5]: df? # Type: DataFrame # String form: # x y # 0 1 a # 1 2 a # 2 3 b # Length: 3 # File: ~/mambaforge/envs/data-science/lib/python3.11/site-packages/pandas/ # core/frame.py # Docstring: # Two-dimensional, size-mutable, potentially heterogeneous tabular data. Figures 1 and 2 show auto-completion features of IPython that allows you to type less.\n  Figure 1: Command history cache in IPython. You can navigate the history with arrows keys or get completion for previous commands.    Figure 2: Tab completion in IPython. Start typing and press Tab to get options of objects or methods that match the text.   IPython vs Jupyter console Yes, JupyterLab console and VS Code’s interactive window are effectively an IPython console. However they share the same flaw: they are associated with a single .py or .ipynb file.\nThis makes all the difference. It induces you to work on a single file. Even while exploring and testing, you should be thinking how to organize modules at different files.\n  Setting up IPython in VS Code First, make sure you have the VS Code’s Python extension installed.\nYou also need to install ipython package in your Python environment. It is good practice to create an isolated environment to work on each project. There are many environment managers for Python, like venv and Conda.\n# virtualenv python -m venv /path/to/venv source /path/to/venv/bin/activate pip install ipython # Conda conda create --name my-env python=3.9 ipython conda activate my-env Figure 3 shows how to select the interpreter from this environment when working on your files. You can also press F1 (or Ctrl + Shift + P) and search Python: Select Interpreter.\n  Figure 3: Selecting the Python interpreter in VS Code.  Now set launch arguments to open an IPython session instead of the default Python terminal. Open VS Code settings file: F1 (or Ctrl + Shift + P) \u0026gt; Preferences: Open User Settings (JSON)\n{ ..., \u0026quot;python.terminal.launchArgs\u0026quot;: [ \u0026quot;-m\u0026quot;, \u0026quot;IPython\u0026quot;, ], ... } IPython profiles IPython can use multiple profiles, with separate configuration and history. By default, if you don’t specify a profile, IPython always runs in the default profile.\nProfiles have a configuration file which you can use to customize IPython options. If you don’t have one yet (usually at ~/.ipython/profile_default/ipython_config.py), you may create it with\n# Create an IPython profile by name # If `profilename` is empty, use the default profile $ ipython profile create [profilename] # Check config file\u0026#39;s location $ ipython locate profile [profilename] Use --profile option in VS Code settings to select a non-default profile.\n{ ..., \u0026quot;python.terminal.launchArgs\u0026quot;: [ \u0026quot;-m\u0026quot;, \u0026quot;IPython\u0026quot;, \u0026quot;--profile\u0026quot;, \u0026quot;profilename\u0026quot; ], ... }  Auto-reloading modules Imagine you have a Python module, bar.py, with some useful functions you will reuse on other script.\n# bar.py def foo(): return \u0026quot;Hello World\u0026quot; In [1]: from bar import foo In [2]: foo() Out[2]: \u0026#39;Hello World\u0026#39; Now suppose that you make some change to foo() function in the bar.py file.\n# bar.py def foo(): return \u0026quot;Hey, you\u0026quot; You would like that to be updated in your IPython session too, because you want to be iterative with your code. However, that is not the default behavior.\nIn [3]: from bar import foo In [4]: foo() Out[4]: \u0026#39;Hello World\u0026#39; If you are not working at a single gigantic Python file or Jupyter notebook that does everything but instead building a maintainable modular code, it would be too troublesome and time-consuming to close the terminal, reopen IPython and reload functions/classes from modules every time there are changes. When exploring data or models it is even worse, since you have to reload data or maybe re-run a training step.\nFortunately, there is an built-in extension called autoreload to change that behavior (and with some flexibility).\n %autoreload 2 Reload all modules (except those excluded by %aimport) every time before executing the Python code typed.\n In [5]: %load_ext autoreload In [6]: %autoreload 2 In [7]: foo() Out[7]: \u0026#39;Hey, you\u0026#39; The argument 2 tells autoreload to reload all modules every time before executing the Python code typed. You can automate this step with your IPython configuration file so you don’t need to repeat the commands at every session start up.\nOpen your profile’s configuration file (ipython_config.py) and change/add these lines:.\n## A list of dotted module names of IPython extensions to load. # Default: [] c.InteractiveShellApp.extensions = [\u0026quot;autoreload\u0026quot;] ## lines of code to run at IPython startup. # Default: [] c.InteractiveShellApp.exec_lines = [\u0026quot;%autoreload 2\u0026quot;]   tl;dr Make sure VS Code’s Python extension is installed. Create a Python environment and install ipython. Select it as Python interpreter in VS Code. Open VS Code settings: F1 \u0026gt; Preferences: Open User Settings (JSON) Set python.terminal.launchArgs to run IPython:\n{ ..., \u0026quot;python.terminal.launchArgs\u0026quot;: [ \u0026quot;-m\u0026quot;, \u0026quot;IPython\u0026quot; ], ... } Create IPython profile:\nipython profile create [profilename] Enable autoreload extension in the configuration file.\nc.InteractiveShellApp.extensions = [\u0026quot;autoreload\u0026quot;] c.InteractiveShellApp.exec_lines = [\u0026quot;%autoreload 2\u0026quot;] Run selected code with Shift + Enter\n   ","permalink":"https://gabriel-msilva.github.io/melloc/post/2023-03-12-vscode-ipython-setup/","summary":"Failing when working on something new is a given. Iterate quickly, fail fast. This post shows how IPython can change your workflow and how to set up it on VS Code.","title":"Productivity and IPython for Data Science"},{"content":" You can find the code used to generate the post’s images and animations in github.com/gabriel-msilva/fractal-sets.\nUpdate 2022-10-10: Fixed first example for Mandelbrot set.\nFractals are a beautifully complex – and I usually do not use these words together – topic in Mathematics. Among many conceptual disagreements between mathematicians, at some point Benoit Mendelbrot proposed a simple and approachable definition:\n A fractal is a shape made of parts similar to the whole in some way.\n Figure 1 illustrates this. You could painstakingly count how many triangles do you see to measure your IQ in some online test, but let’s look at some properties of this shape.\n  Figure 1: A simple example of a fractal, called Sierpiński triangle. The triangular patterns repeat over and over in smaller scales.  We notice that the main equilateral triangle repeats itself into many other smaller triangles. More formally, this property is called self-similarity, when parts of a shape have exactly or approximately similar parts of itself (“the whole”). This is observed by zooming into the shape, just to find the same patterns again.\nDespite the figure presenting a limited number of triangles, you could easily extrapolate the shape at arbitrarily smaller scales by understanding the repeating pattern, the rule used to create this shape. Maybe something like:\nStart with an equilateral triangle of any size; Inscribe another equilateral triangle into it and remove this area; Repeat step 2 for each triangle formed  Figure 1 illustrates the first iterations Notice that this set of rules does not halt, i.e. it goes on indefinitely. If you did not stop drawing this pattern, you would obtain a fractal called Sierpiński triangle.\n  Figure 2: First iterations to build a Sierpiński triangle.  This a simple example of a fractal. There are many others that create more complex patterns, but not necessarily by much more complex rules. Gaston Julia and Benoit Mandelbrot were influential mathematicians in fractal geometry, well-known for the sets which take their names.\nMandelbrot set The Mandelbrot set is the set of complex numbers \\(c = x + yi\\) for which the sequence\n\\[ z_{n + 1} = z_n^2 + c, \\quad z_0 = 0 \\]\ndoes not diverge as \\(n\\) grows. For example, when \\(c = 1\\),\n\\[\\begin{alignat}{4} z_0 \u0026amp;=\u0026amp; \u0026amp; \u0026amp; 0 \\\\ z_1 \u0026amp;=\u0026amp; 0^2 \u0026amp; +1 =\u0026amp; 1 \\\\ z_2 \u0026amp;=\u0026amp; 1^2 \u0026amp; +1 =\u0026amp; 2 \\\\ z_3 \u0026amp;=\u0026amp; 2^2 \u0026amp; +1 =\u0026amp; 5 \\\\ z_4 \u0026amp;=\u0026amp; 5^2 \u0026amp; +1 =\u0026amp; 26 \\\\ \u0026amp; \\dots \\\\ \\end{alignat}\\]\nWe can see that \\(|z_n| \\rightarrow \\infty\\) when \\(n \\rightarrow \\infty\\) and thus \\(c = 1\\) is not part of the Mandelbrot set. On the other hand, for \\(c = -1\\), \\(z_n\\) oscillates between \\(-1\\) and \\(0\\), i.e. it remains bounded, so it belongs to the set.\n\\[\\begin{alignat}{4} z_0 \u0026amp;=\u0026amp; \u0026amp; \u0026amp; 0 \\\\ z_1 \u0026amp;=\u0026amp; 0^2 \u0026amp; -1 =\u0026amp; -1 \\\\ z_2 \u0026amp;=\u0026amp; (-1)^2 \u0026amp; -1 =\u0026amp; 0 \\\\ z_3 \u0026amp;=\u0026amp; 0^2 \u0026amp; -1 =\u0026amp; -1 \\\\ z_4 \u0026amp;=\u0026amp; (-1)^2 \u0026amp; -1 =\u0026amp; 0 \\\\ \u0026amp; \\dots \\\\ \\end{alignat}\\]\nFor the boundary \\(|z| \\leq 2\\) (\\(|z| = \\sqrt{x^2 + y^2}\\), so a circle in the complex plane), the Mandelbrot set looks like Figure 3. We are looking at \\(c\\) points for which \\(|z_n| \\leq 2\\) for every \\(n = \\{1, 2, 3, \\dots, 100\\}\\) iteration.\n  Figure 3: The Mandelbrot set for 100 iterations.  It also interesting to see how many iterations does it take for \\(z_n\\) to escape the boundary. For \\(c = -0.8 + 0.5i\\) in Figure 4, \\(z\\) takes \\(n = 6\\) iterations to escape the boundary.\n Figure 4: For \\(c = -0.8+ 0.5i\\), \\(z\\) escapes the boundary \\(|z| \\leq 2\\) at the 6th iteration.  If we map this iteration count to the color aesthetic of each point \\(c\\), we get Figure 5.\n  Figure 5: Colored Mandelbrot set for 100 iterations, where the color represents the iteration \\(n\\) when \\(|z_n| \u0026gt; 2\\).  But where is the self-similarity? We need to zoom-in to see it better – and there are many “hidden” repeating patterns inside the Mandelbrot set. Figure 6 focus on one of these, but you probably can spot other across the way.\n  Figure 6: Self-similarity in the Mandelbrot set.  Actually, the colored Mandelbrot is not so smooth as can be seen on Figure 5. It creates “bands of color” as in Figure 7a, because the iteration count is a natural number. The continuous coloring (Figure 7b) is obtained by applying an algorithm called “normalized iteration count”, which adds \\(\\delta \\in [0, 1[\\) to iteration count as function of \\(|z|\\).\n  Figure 7: Continuous (smooth) coloring on the Mandelbrot set.   Julia set Similarly to the Mandelbrot set, the Julia set is the set of complex numbers \\(z\\) for which the recursive function\n\\[ R(z) = \\frac{P(z)}{Q(z)} \\]\ndoes not diverge (or escapes a boundary) for a increasing number of iterations. \\(P\\) and \\(Q\\) are polynomials without common divisors. Consider a particular Julia set where \\(R(z) = z^2 + c\\), then we have an equation analogous to the logistic mapping of the Mandelbrot set\n\\[ z_{n + 1} = z_n^2 + c \\]\nbut for a fixed complex \\(c\\) instead of a fixed \\(z_0\\). In the same manner, we will count how many iterations does it take for \\(z_n\\) to escape the boundary \\(|z| \\leq 2\\) for a given \\(c\\). Figure 8 shows this particular Julia set for two values of \\(c\\).\n  Figure 8: Quadractic Julia sets for (a) \\(c = -1\\) and (b) \\(c = i\\) with 200 iterations.  The Julia set also has many self-similarities, as illustrated by Figure 9.\n  Figure 9: Zooming in point \\(z \\approx 1.618\\) of the Julia set \\(J_c(z) = z^2 + c\\) for \\(c = -1\\).   Relation between Mandelbrot and Julia sets While Mandelbrot set is mapped into \\(z\\) complex plane, Julia set is mapped into \\(c\\) complex plane. So, for each point of the Mandelbrot set there is a corresponding Julia set, and vice-versa. Figure 10 shows this correspondence along a line segment on the Mandelbrot set.\n  Figure 10: Julia sets \\(J_c(f)\\) along the line segment \\(c = ai, -1 \\leq a \\leq 1\\).  Let’s take this opportunity to remember “the most remarkable formula in mathematics”, the Euler’s formula:\n\\[ e^{i x} = \\cos x + i \\sin x, \\quad \\text{for any } x \\in \\mathbb{R} \\] When \\(x = \\pi\\),\n\\[ e^{i\\pi} + 1 = 0 \\]\nA beautiful identity as it contains five of the most fundamental numbers in Mathematics. Let \\(c = r e^{i \\theta}\\), then\n\\[ \\begin{cases} \\mathrm{Re}(c) = r \\cos{\\theta} \\\\ \\mathrm{Im}(c) = r \\sin{\\theta} \\end{cases} \\]\nwhich is a circumference in the complex plane, thus connecting trigonometry and complex numbers. Figure 11 shows Julia sets for a counter-clockwise rotation around a circumference \\(r e^{i \\theta}\\).\n  Figure 11: Julia sets \\(J_c(f)\\) around the circumference \\(c = 0.7885 e^{i \\theta}\\) in the complex plane.   Final notes Fractal shapes can be seen in Nature like in a humble cauliflower, but they are also applied in technology, as fractal antennas, or in explaining considerable differences in coastline length measurements.\nAside from its applications, I think fractals are just pretty neat. I mean, look at this:\n To close, my recommendation of a couple of videos from amazing YouTube channels to dive more into fractals.\n This equation will change how you see the world (the logistic map), Veritasium Fractals are typically not self-similar, 3Blue1Brown   ","permalink":"https://gabriel-msilva.github.io/melloc/post/2022-02-08-mandelbrot-and-julia-sets/","summary":"Fractals are a beautifully complex \u0026ndash; and I usually do not use these words together \u0026ndash; topic in Mathematics. This post scratches the theory behind with two well-know fractals.","title":"Mandelbrot and Julia sets"}]